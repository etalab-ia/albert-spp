stages:
  - build
  - deploy

############################################
################# CONFIG ###################
############################################

before_script:
  - | # export env file and copy routing table to pyalbert config
    if [[ $CI_COMMIT_BRANCH = "staging" ]]; then
      echo "info: export staging env file environment"
      while IFS='=' read -r key value; do export "$key"="$value"; done < <(grep -v "^#" $STAGING__ENV_FILE)
      cp ${STAGING__ENV_FILE} .env
    elif [[ $CI_COMMIT_BRANCH = "main" ]]; then
      echo "info: export production env file environment"
      while IFS='=' read -r key value; do export "$key"="$value"; done < <(grep -v "^#" $PROD__ENV_FILE)
      cp ${PROD__ENV_FILE} .env
    fi

############################################
################## BUILD ###################
############################################

build:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: build
  image: docker:latest
  services:
    - docker:dind
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # build and push api image to gitlab registry
      docker login --username gitlab-ci-token --password $CI_JOB_TOKEN $CI_REGISTRY
      docker build --rm --tag ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG} --file ./Dockerfile .
      docker push ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG}

############################################
################## DEPLOY ##################
############################################

deploy:
  rules:
    - if: $CI_COMMIT_BRANCH == "staging" || $CI_COMMIT_BRANCH == "main"
      when: manual
      allow_failure: true  # to avoid blocked state
  stage: deploy
  image: alpine:latest
  script:
    - | # ssh connection setup
      chmod og= $CI_DEPLOY_USER_SSH_PRIVATE_KEY
      apk update
      apk add openssh-client
    - | # send deployment files to remote server
      mkdir -p ./${CI_JOB_ID}
      cp ./docker-compose.yml ./${CI_JOB_ID}/docker-compose.yml
      cp $API_KEYS ./${CI_JOB_ID}/spp_api_keys.json
      cp .env ./${CI_JOB_ID}/.env
      echo "
      CI_REGISTRY_IMAGE=${CI_REGISTRY_IMAGE}
      CI_API_IMAGE_TAG=${CI_API_IMAGE_TAG}
      CI_VLLM_IMAGE_TAG=${CI_VLLM_IMAGE_TAG}
      APP_VERSION=${CI_API_IMAGE_TAG}
      API_KEYS_FILE=/home/${CI_DEPLOY_USER}/keys/spp_api_keys.json
      COMPOSE_FILE=/home/${CI_DEPLOY_USER}/${CI_JOB_ID}/docker-compose.yml
      COMPOSE_PROJECT_NAME=spp
      " >> ./${CI_JOB_ID}/.env
      scp -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no -r ./${CI_JOB_ID} ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST}:/home/${CI_DEPLOY_USER}/${CI_JOB_ID}
    - | # deploy api container to remote server
      ssh -i $CI_DEPLOY_USER_SSH_PRIVATE_KEY -o StrictHostKeyChecking=no ${CI_DEPLOY_USER}@${CI_DEPLOY_HOST} "
      mkdir -p /home/${CI_DEPLOY_USER}/keys
      chmod 700 /home/${CI_DEPLOY_USER}/keys
      mv /home/${CI_DEPLOY_USER}/${CI_JOB_ID}/spp_api_keys.json /home/${CI_DEPLOY_USER}/keys/spp_api_keys.json
      docker login $CI_REGISTRY --username gitlab-ci-token --password-stdin <<<$CI_JOB_TOKEN
      cd /home/${CI_DEPLOY_USER}/${CI_JOB_ID}
      docker compose --env-file .env down
      docker tag ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG} ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG}-old || true
      docker image rm ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG} || true
      docker compose --env-file .env up --detach
      docker image rm ${CI_REGISTRY_IMAGE}/api:${CI_API_IMAGE_TAG}-old || true
      rm -rf ~/${CI_JOB_ID}
      "